# 2.5 Получение экземпляра из контейнера
После того как тип был привязан к контейнеру, можно попытаться получить его экземпляр.

Это делается с помощью метода `get()` контейнера:

```ts
declare function get<Type extends keyof TypeMap>(
    type: Type, 
    name: TBindingName = null,
): TypeMap[Type]
```
где,
- `type` - Ключ-типа, который требуется получить
- `name` - (опц.) имя экземпляра, для получения по имени

В случае, если такой экземпляр еще не создан или имеет жизненный цикл "Transient",
то будет создан новый экземпляр с помощью привязанной фабрики.

```ts
type TypeMap = {
    baseUrl: string
    httpClieht: IHttpClient
}

const container = DIContainer.builder<TypeMap>()
    .bindInstance('baseUrl', 'https://example.com/api/v1')
    .bindFactory(
        'httpClient', 
        r => new HttpClient(
            r.get('baseUrl'),  // Для предоставления зависимостей
        ),                     // используется этот же 'get' метод
    )
    .build()

// Используем метод 'get', чтобы получить 'HttpClient' из конетейнера
const http = container.get('httpClient')
```

## Как не следует использовать get-метод
Обычно имея такой инструмент как "получить любой экземпляр",
порождает желание экспортировать "DIContainer"
и получать экземпляры в любой точке приложения.

Так делать не надо. В итоге вместо "Dependency Injection"
получится анти-паттерн "Service locator",
который может еще сильнее запутать архитектуру вашего приложения.

Старайтесь получить необходимые экземпляры на старте приложения,
а остальные передавать через конструкторы.

Бывает все же нужно получить какой-нибудь экземпляр в другой части приложения.
Например, там где сложно выполнить инъекцию с помощью контейнера.
Однако такое маловероятно, обычно это уже свидетельствует о плохой архитектуре.
В таком случае можно использовать [провайдеры](2-7_delayed-injection.md), чтобы была возможность получить не любой экземпляр,
а только конкретного типа. Это тоже плохой подход, но лучше, чем передавать весь контейнер.