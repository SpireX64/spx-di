# 1.1 - Начало работы

**SpireX DI** это библиотека, предоставляющая инструменты 
для реализации процесса инъекции зависимостей в проектах TypeScript/JavaScript.

## Установка
Установка выполняется с помощью предпочитаемого вами менеджера пакетов:
```shell
> npm install @spirex/di
> yarn add @spirex/di
> pnpm add @spirex/di
```
Все определения типов уже включены в пакет и не требуют дополнительной установки.

## Базовый процесс интеграции в проект
- Структурирование проекта с учетом инверсии управления (IoC).
- На запуске приложения:
  - Создание сборщика контейнера `DIContainer.builder()`;
  - Привязка компонентов проекта;
  - Сборка контейнера и сохранение ссылки на него.
- Во время работы приложения
  - Разделение проекта на области 
  - Получение экземпляров компонентов

## Структурирование проекта
Основная идея *инверсии зависимостей* в том,
чтобы не связывать компоненты приложения вместе,
а позволять "заменять" свои зависимости.

Например, мы хотим написать простое приложение,
которое выводит текущую дату в консоль.

Однако, нам нужно уметь тестировать это
или использовать в среде, где вывод в консоль недоступен.

```ts
// Определяем интерфейс функции, которая будет выполнять вывод.
// Нам *все равно* как она это делает. 
type OutputPrinter = (text: string) => void

// Определяем интерфейс функции, которая будет возвращать дату.
// Нас так же не интерисует как она это делает, главное получить дату.
type DateProvider = () => Date

// Интерфейс, который описывает метод вывода текущей даты.
// Но не определяет, как этот вывод будет выполняться.
interface IDateWriter {
    writeDate(): void
}

// Определяем класс, реализующий интерфейс "IDateWriter"
// Используя "OutputPrinter", этот класс может делать вывод
// Используя "DateProvider", можно получить дату, которая будет распечатана.
class DateWriter implements IDateWriter {
  public constructor(
    private print: OutputPrinter,
    private getDate: DateProvider,
  ) {
  }

  public writeDate(): void {
    this.print(this.getDate().toDateString())
  }
}

// Реализация интерфейса "OutputPrinter"
// Она позволяет использовать стандартный вывод в консоль
const consoleOutput: OutputPrinter = console.log
        
// Реализация интерфейса "DateProvider"
// Она предоставляет текущую дату
const getDateNow: DateProvider = () => new Date()
```

На этом структура готова.
Мы подготовили интерфейсы и "установили" их зависимости друг от друга.

## Создание контейнера и связывание компонентов приложения
На запуске приложения, нужно создать контейнер и связать компоненты.
Компонентом приложения может являться любой JS-тип данных.
Например строки, массивы, функции, объекты и т.д.

В идеале, чтобы компонент был привязан с типом своего интерфейса,
чтобы минимизировать связанность в приложении.

После создания контейнера нужно не забыть сохранить ссылку на него,
чтобы далее иметь возможность получать привязанные экземпляры типов из него.
```ts
// В начале определим ключи типов (type keys).
// Так получилось, что после компиляции TypeScript в JavaScript
// все определенные типы и интерфейсы теряются.
// Поэтому нам нужно создать ключи, которые будут помогать нам
// идентифицировать эти типы в системе, даже после компиляции.
const Types = {
  OutputWriter: Symbol('OutputWriter'),
  DateProvider: Symbol('DateProvider'),
  DateWriter: Symbol('DateWriter'),
}

// Теперь нужно связать ключи типов (type keys)
// с нашими интерфейсами.
// Это позволяет контейнеру сохранять типизацию компонентов
// обеспечивая строгую типозацию как во время привязки,
// так и во время запроса компонентов из контейнера,
// приводя ключи типов и определенным типам TypeScript.
type TypeMap = {
  [Types.OutputWriter]: OutputWriter;
  [Types.DateProvider]: DateProvider;
  [Types.DateWriter]: IDateWriter;
}

function buildContainer() {
    // Создаем сборщик контейнера,
    // и передаем ему карту типов (type map)
    const builder = DIContainer.builder<TypeMap>()
  
    // Связываем типы функций и их реализацией.
    // Они уже созданы и не требуют зависимостей,
    // поэтому используем привязку по значению (bindInstance)
    builder
      .bindInstance(Types.OutputWriter, consoleOutput)
      .bindInstance(Types.DateProvider, getDateNow)
  
    // Теперь привязываем реализацию интерфейса "IDateWriter"
    // Класс реализующий его требует предоставить ему для работы
    // "OutputWriter" и "DateProvider". То есть он зависит от них.
    // Для этого воспользуемся привязкой с помощью фабрики,
    // что позволит удовлетворить его требования
    builder
      .bindFactory(
          Types.DateWriter, 
          r => new DateWriter(
              r.get(Types.OutputWriter),
              r.get(Types.DateWriter), 
          ),
      )
  
    // Контейнер сконфигурирован, теперь можно создать его
    // не забыв вернуть ссылку.
    return builder.build()
}
```
Контейнер готов к использованию!

После того как контейнер был собран, изменить его конфигурацию больше нельзя.
Это сделано для обеспечения стабильности и сохранения типизации.
Если бы конфигурация контейнера изменялась динамически во время работы приложения,
то нельзя быть уверенным, что контейнер предоставит нужный экземпляр. 

## Запуск приложения

Теперь на запуске приложения, используя контейнер,
можно получить экземпляр реализующее интерфейс `IDateWriter`
и распечатать дату с помощью него:
```ts
(function() {
    const container = buildContainer()
    const dateWriter = container.get(Types.DateWriter)
    dateWriter.writeDate()
})()
```

## Как оно работает?

- Собираем контейнер, который был ранее сконфигурирован 
  и знает о типах используемых в приложении.
- Используя метод контейнера `get(...)`, 
  мы просим его предоставить нам нужный тип данных.
  В нашем случае это `Types.DateWriter`. А внутри его...
  - Используя карту типов `TypeMap`, контейнер выводит тип как `IDateWriter`,
    что избавляет нас от лишних приведений типов.
  - Далее он находит привязку типа `Types.DateWriter`
  - Определяет, что это фабрика, и пытается создать экземпляр с помощью нее.
  - В процессе выполнения фабрики, обнаруживает зависимость
    от типов `Types.OutputWriter` и `Types.DateWriter`
  - Находит привязку `Types.OutputWriter` и определяет,
    что это готовое к использованию значение.
    Создавать его не нужно, поэтому он сразу отдает его значение.
  - Так же находит привязку `Types.DateWriter`.
    Это так же готовое значение, поэтому сразу возвращает и его.
  - Далее фабрика, получив все необходимые зависимости,
    создает класс `DateWriter`, реализующий интерфейс `IDateWriter`.
  - Контейнер сохраняет ссылку на него
    и в итоге возвращает его из функции `get(..)`.
- Получив экземпляр `IDateWriter`, сохраняем его в переменную, чтобы далее использовать.
- Вызываем метод `writeDate()`, что выполняет вывод текущей даты на экран.

Теперь, если когда-нибудь потребуется изменить способ вывода или получение даты,
достаточно изменить привязку в контейнере, предоставив новую реализацию.
При этом все компоненты использующие этот тип изменять не придется.
