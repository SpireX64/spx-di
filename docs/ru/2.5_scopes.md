# Области доступности
Контейнер поддерживает области доступности.
Это позволяет иметь один экземпляр типа на область.

## Scoped экземпляр
Такое поведение экземплярам обеспечивает жизненный цикл `Scoped`.
Если требуется чтобы экземпляр был доступен только в пределах области,
то нужно указать ему `Scoped` жизненный цикл при конфигурации контейнера:

```ts
builder
    .bindFactory(
        Types.MyType,
        () => new MyTypeImpl(),
        Lifecycle.Scoped, // Ограничен областью доступности
    )
```

## Создание областей
Область создается при первом обращении к ней с помощью метода `scope()`:
```ts
declare function scope(key: TScopeKey): IDependencyResolver
```
где,
- `key` - Уникальный идентификатор области. 
          Может принимать значения типов `string` и `symbol`.

Возвращает объект, с помощью которого можно получать экземпляры
из данной области.

## Получение экземпляров области
После создания области, можно попросить ее предоставить
необходимый экземпляр:

```ts
const instA = container.scope('my-scope').get(Types.MyType)
const instB = container.scope('my-scope').get(Types.MyType)
const instC = container.scope('other').get(Types.MyType)

console.assert(instA === instB) // Один и тот же экземпляр
console.assert(instA !== instC) // Разные экземпляры
```

## Закрытие области
Если область доступности больше не нужна,
то ее нужно закрыть с помощью метода `closeScope`:
```ts
declare function closeScope(key: TScopeKey): void
```

После чего область будет закрыта и все ссылки на ее экземпляры
будут удалены из контейнера.

Если обратится к области после ее закрытия,
будет создана новая область с новыми экземплярами.

```ts
const instA1 = container.scope('A').get(Types.MyType)

container.closeScope('A') // Закрываем область 'A'
// Все экземпляры области 'A' были удалены из контейнера

const instA2 = container.scope('A').get(Types.MyType)
// Была создана новая область 'A'
// Создан новый экземпляр 'MyType' в новой области 'A'

console.assert(instA1 !== instA2) // разные экземпляры
```


### Авто-очистка экземпляров
Контейнер поддерживает механизм авто-очистки экземпляров,
при закрытии области в которой они были созданы.

Это может помочь очистить используемые ресурсы
или обновить состояние других экземпляров при закрытии области.

Чтобы реализовать такое поведение, нужно создать метод
`dispose` у экземпляра.
Если контейнер обнаружит метод с таким именем у экземпляра,
он будет вызван автоматически, при закрытии области.

Например, есть класс музыкального плеера,
который позволяет открывать и воспроизводить музыкальные файлы.

Он используется только в определенном разделе приложения.
Поэтому при выходе из этого раздела, нужно остановить воспроизведение
и закрыть музыкальный файл.
Если этого не сделать, мы потеряем ссылку на плеер
и музыка продолжит играть без возможности остановить ее.
```ts
// MusicPlayer.ts
class MusicPlayer implements IMediaPlayer {
    // ... 
    
    public dispose(): void {
        // Если вышли из области, где экземпляр плеера доступен
        // останавливаем воспроизведение и закрываем музыкальный файл
        if (this.isFileReady) {
            if (this.isPlaying) this.stop()
            this.closeFile()
        }
    }
}

// di.ts
const Types = {
    MediaPlayer: IMediaPlayer,
}

type TypeMap = {
    [Types.MediaPlayer]: IMediaPlayer;
}

function buildContainer() {
    return DIContainer.builder<TypeMap>()
        .bindFactory(
            Types.MediaPlayer,
            () => new MusicPlayer(),
            Lifecycle.Scoped, // Ограничен областью
        )
        .build()
}

// main.ts
function main() {
    const container = buildContainer()
    const player = container.scope('music').get(Types.MediaPlayer)
    player.open('music.ogg')
    player.play()
    
    container.closeScope('music') // Закрываем область "music"
    // MusicPlayer.dispose() был вызыван
}
```
